using System;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Xml;
using Microsoft.VisualStudio.TextTemplating.VSHost;

namespace ESP.CodeGenerators
{
    /// <summary>
    /// Generates strongly typed classes based on EPiServer language files.
    /// </summary>
    [Guid("5DEE0CB7-09EB-43A8-941F-446F2C828106")]
    public sealed class EPiLabelResourceGenerator : BaseCodeGeneratorWithSite
    {
        public override string GetDefaultExtension()
        {
            return ".resources.cs";
        }

        protected override byte[] GenerateCode(string inputFileName, string inputFileContent)
        {
            StringBuilder builder = new StringBuilder();
            try
            {
                XmlDocument doc = new XmlDocument();
                doc.LoadXml(inputFileContent);

                builder.Append(@"/// This file is autogenerated by a tool.
using System;

using EPiServer.Core;

namespace " + this.FileNamespace + @"
{

");
                foreach (XmlNode topNode in doc.SelectNodes("languages/language/*"))
                {
                    ProcessClass(topNode, builder);
                }

                builder.Append(@"
}
");
            }
            catch (Exception ex)
            {
                builder.Append(ex.Message);
                builder.Append(ex.StackTrace);
            }

            string output = builder.ToString();
            byte[] bytes = Encoding.UTF8.GetBytes(output);
            return bytes;
        }

        private static void ProcessClass(XmlNode topNode, StringBuilder builder)
        {
            string className = topNode.Name;
            builder.Append("\tpublic static class " + className + @"
	{
");

            foreach (XmlNode child in topNode.ChildNodes)
            {
                Process(child, builder, "/" + topNode.Name, string.Empty);
            }

            builder.AppendLine("\t}");
        }

        private static void Process(XmlNode root, StringBuilder builder, string path, string prefix)
        {
            string newPath = path + "/" + root.Name;
            string newPrefix = prefix + "_" + root.Name;
            XmlElement[] childElements = root.ChildNodes.OfType<XmlElement>().ToArray();
            if (childElements.Any())
            {
                foreach (XmlElement element in childElements)
                {
                    Process(element, builder, newPath, newPrefix);
                }
            }
            else
            {
                string propertyName = newPrefix.Trim('_');
                string labelPath = newPath;

                // add a comment that contains the original text value (useful in IDE)
                builder.AppendFormat(@"
		/// <summary>
		/// Gets a translated label. Original value: '{0}'.
		/// </summary>
", root.InnerText.Replace('\r', ' ').Replace('\n', ' '));
                builder.AppendLine(
                    "\t\tpublic static string $PROPERTYNAME$ { get { return LanguageManager.Instance.Translate(\"$LABELPATH$\"); } }"
                    .Replace("$PROPERTYNAME$", propertyName)
                    .Replace("$LABELPATH$", labelPath));

                // if the label contains {0} then generate a Format method too!
                if (root.InnerText.Contains("{0}"))
                {
                    builder.Append(@"
		public static string $PROPERTYNAME$Format(params object[] args)
		{
			return string.Format($PROPERTYNAME$, args);
		}
".Replace("$PROPERTYNAME$", propertyName));
                }
            }
        }
    }
}
