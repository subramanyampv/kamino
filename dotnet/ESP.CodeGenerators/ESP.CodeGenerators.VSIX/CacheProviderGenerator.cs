using System;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using ICSharpCode.NRefactory.CSharp;
using Microsoft.VisualStudio.TextTemplating.VSHost;

namespace ESP.CodeGenerators
{
    [Guid("B65130B0-809E-415F-AE0C-D130F6AA02BD")]
    public class CacheProviderGenerator : BaseCodeGeneratorWithSite
    {
        public override string GetDefaultExtension()
        {
            return ".designer.cs";
        }

        protected override byte[] GenerateCode(string inputFileName, string inputFileContent)
        {
            StringBuilder builder = new StringBuilder();
            try
            {
                string interfaceName = Path.GetFileNameWithoutExtension(inputFileName) ?? string.Empty;
                string className = "Cached" + interfaceName.Substring(1);

                builder.Append(@"/// This file is autogenerated by a tool.
using System;

using ESP.Core.Interfaces;
using ESP.Core.Modules.Cache;
using ESP.Core.Objects.Social;

namespace " + FileNamespace + @"
{
	public partial class $CLASSNAME$ : $INTERFACENAME$
	{
		private readonly $INTERFACENAME$ _backend;

		/// <summary>
		/// Initializes a new instance of the <see cref=""$CLASSNAME$""/> class. 
		/// </summary>
		/// <param name=""backend"">
		/// The backend provider.
		/// </param>
		public $CLASSNAME$($INTERFACENAME$ backend)
		{
			_backend = backend;
		}

		/// <summary>
		/// Gets the cache key to use.
		/// </summary>
		/// <param name=""methodName"">The method that is doing the caching</param>
		/// <param name=""extraKeys"">More keys to append to the cache key.</param>
		/// <returns>A cache key for the given method and page</returns>
		protected string GetCacheKey(string methodName, params string[] extraKeys)
		{
			string moreKey = string.Join(""-"", extraKeys);
			return string.Format(""$INTERFACENAME$_{0}{1}"", methodName, moreKey);
		}

#region Auto generated get methods
".Replace("$INTERFACENAME$", interfaceName).Replace("$CLASSNAME$", className));

                CSharpParser parser = new CSharpParser();
                SyntaxTree tree = parser.Parse(inputFileContent);
                foreach (var mi in tree.Descendants.OfType<MethodDeclaration>().Where(m => m.Name.StartsWith("Get")))
                {
                    builder.AppendFormat("public virtual {0} {1}(", mi.ReturnType, mi.Name);
                    builder.Append(string.Join(", ", mi.Parameters.Select(p => string.Format("{0} {1}", p.Type, p.Name))));
                    builder.AppendLine(")");
                    builder.AppendLine("{");
                    builder.AppendFormat("\tstring cacheKey = GetCacheKey(\"{0}\"{1});\r\n", mi.Name,
                                         string.Concat(
                                             mi.Parameters.Select(
                                                 p =>
                                                 string.Format(", {0}", p.Type.ToString() == "string" ? p.Name : p.Name + ".ToString()"))));
                    builder.AppendFormat("\treturn CacheManager.CacheMethod(cacheKey, () => _backend.{0}({1}));", mi.Name,
                                         string.Join(", ", mi.Parameters.Select(p => p.Name)));
                    builder.AppendLine();
                    builder.AppendLine("}");
                }

                builder.Append(@"
#endregion
	}
}
");
            }
            catch (Exception ex)
            {
                builder.Append(ex.Message);
                builder.Append(ex.StackTrace);
            }

            string output = builder.ToString();
            byte[] bytes = Encoding.UTF8.GetBytes(output);
            return bytes;
        }
    }
}
